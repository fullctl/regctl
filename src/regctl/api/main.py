# generated by fastapi-codegen:
#   filename:  schema.json
#   timestamp: 2024-07-17T15:54:18+00:00

from __future__ import annotations

import json
from typing import Union
from pydantic import ValidationError
import ipaddress
from fastapi import FastAPI, Query, HTTPException
from fastapi.encoders import jsonable_encoder
from fastapi.responses import JSONResponse
import datetime

import structlog
from regctl.api.models import (
    Domain,
    Entity,
    IPNetwork,
    ListAsnPrefixGetResponse,
    ListPrefixAsnGetResponse,
    Network,
    Source,
    RdapAutNum,
    RdapDomain,
    RdapEntity,
    RdapIPNetwork,
)

from regctl.irrexplorer import get_asn_routing_data, get_prefix_routing_data
from regctl.api.cache import cache_result

import rdap
import re

from rdap.exceptions import RdapNotFoundError, RdapHTTPError
from rdap.context import RdapRequestContext, rdap_request


log = structlog.get_logger()

class PrettyJSONResponse(JSONResponse):
    """
    Custom JSON response class that pretty-prints the JSON

    TODO: do we want a toggle for this?
    """
    def render(self, content: any) -> bytes:
        return json.dumps(
            content,
            ensure_ascii=False,
            allow_nan=False,
            indent=4,
            separators=(", ", ": "),
        ).encode("utf-8")

app = FastAPI(
    title='regctl',
    description='Standardized output of registration data',
    version='0.1',
    default_response_class=PrettyJSONResponse
)

def validate_asn(asn: str | int) -> int:
    """
    Validate an ASN and return it as an integer.

    Arguments:

    - `asn` (str | int): The ASN to validate.

    Returns:

    - int: The validated ASN as an integer.
    """
    try:
        asn_int = int(asn)
        if 0 <= asn_int <= 4294967295:  # Valid ASN range
            return asn_int
        raise ValueError
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid ASN")

def validate_prefix(prefix: str) -> str:
    """
    Validate an IP prefix and return it as a string.

    Arguments:

    - `prefix` (str): The IP prefix to validate.

    Returns:

    - str: The validated IP prefix as a string.
    """

    try:
        # This will validate both IPv4 and IPv6 prefixes
        network = ipaddress.ip_network(prefix, strict=False)
        return str(network)
    except ValueError:
        raise HTTPException(status_code=400, detail="Invalid prefix format")


def error_response(exc: Exception) -> JSONResponse:
    """
    Error response handling.
    """
    request = rdap_request.get()

    code = None
    message = None
    data = {}
    sources = [Source(**source.model_dump()) for source in request.sources if source.urls]

    try:
        raise
    except RdapNotFoundError:
        code = 404
        message = 'RDAP not found'
    except RdapHTTPError as rdap_exc:
        code = int(re.match(r'.+ returned (\d+)', str(rdap_exc)).group(1))
        message = str(rdap_exc)
    except ValidationError as pydantic_exc:
        code = 400
        message = str("Object validation failed - this is likely an issue to be remedied on our end. The error has been logged and will be investigated.")
        data = pydantic_exc.errors()

        log.error(
            'Validation error',
            errors=data,
            sources=sources,
        )
        log.exception(pydantic_exc)
    except Exception as exc:
        code = 500
        message = 'Internal server error - this is likely an issue to be remedied on our end. The error has been logged and will be investigated.'
        log.exception(exc)

    return JSONResponse(
        status_code=code,
        content=jsonable_encoder({
            'error': message,
            'data': data,
            'sources': sources,
        })
    )

def rdap_client():
    return rdap.RdapClient()

PASSTHROUGH = Query(description='Pass through response from the RDAP server and deliver without normalization.', default=False)

@app.get('/autnum/{asn}', response_model=Union[Network, RdapAutNum])
@cache_result('autnum')
async def get_autnum_asn(asn: int, passthrough=PASSTHROUGH) -> Network:

    """
    Retrieve information about an Autonomous System Number (ASN).

    Path Arguments:

    - `asn` (int): The ASN to look up.

    Query Parameters:

    - `passthrough` (bool): Pass through response from the RDAP server and deliver without normalization. Default is `False`.
    """

    client = rdap_client()
    with RdapRequestContext(client=client):
        try:
            obj = client.get_asn(asn)
            if passthrough:
                return RdapAutNum(**obj._data)
            return Network(**obj.normalized)
        except Exception as exc:
            return error_response(exc)

@app.get('/domain/{domain}', response_model=Union[Domain, RdapDomain])
@cache_result('domain')
async def get_domain_domain(domain: str, passthrough=PASSTHROUGH) -> Domain:

    """
    Retrieve information about a domain.

    Path Arguments:

    - `domain` (str): The domain to look up. e.g., `example.com`.

    Query Parameters:

    - `passthrough` (bool): Pass through response from the RDAP server and deliver without normalization. Default is `False`.
    """

    client = rdap_client()
    with RdapRequestContext(client=client):
        try:
            obj = client.get_domain(domain)
            if passthrough:
                return RdapDomain(**obj._data)
            return Domain(**obj.normalized)
        except Exception as exc:
            return error_response(exc)


@app.get('/entity/{entity}', response_model=Union[Entity, RdapEntity])
@cache_result('entity')
async def get_entity_entity(entity: str, passthrough=PASSTHROUGH) -> Entity:

    """
    Retrieve information about an entity.
    
    Path Arguments:

    - `entity` (str): The entity to look up. e.g., `ABC123-ARIN`.

    Query Parameters:

    - `passthrough` (bool): Pass through response from the RDAP server and deliver without normalization. Default is `False`.
    """

    client = rdap_client()
    with RdapRequestContext(client=client):
        try:
            obj = client.get_entity(entity)
            if passthrough:
                return RdapEntity(**obj._data)
            return Entity(**obj.normalized)
        except Exception as exc:
            return error_response(exc)


@app.get('/ip/{ip}', response_model=Union[IPNetwork, RdapIPNetwork])
@cache_result('ip')
async def get_ip_address(ip:str, passthrough=PASSTHROUGH) -> IPNetwork:
    """
    Retrieve information about an IP address without providing a prefix length.

    Path Arguments:

    - `ip` (str): The IP address to look up

    Query Parameters:

    - `passthrough` (bool): Pass through response from the RDAP server and deliver without normalization. Default is `False`.
    """
    
    client = rdap_client()
    with RdapRequestContext(client=client):
        try:
            obj = client.get_ip(ip)
            if passthrough:
                return RdapIPNetwork(**obj._data)
            return IPNetwork(**obj.normalized)
        except Exception as exc:
            return error_response(exc)
            

@app.get('/ip/{ip}/{mask}', response_model=Union[IPNetwork, RdapIPNetwork])
@cache_result('prefix')
async def get_ip_network(ip:str, mask:int, passthrough=PASSTHROUGH) -> IPNetwork:
    """
    Retrieve information about an IP network.

    Path Arguments:

    - `ip` (str): The IP address to look up
    - `mask` (int): The prefix length

    Query Parameters:

    - `passthrough` (bool): Pass through response from the RDAP server and deliver without normalization. Default is `False`.
    """
    
    client = rdap_client()
    with RdapRequestContext(client=client):
        try:
            obj = client.get_ip(f"{ip}/{mask}")
            if passthrough:
                return RdapIPNetwork(**obj._data)
            return IPNetwork(**obj.normalized)
        except Exception as exc:
            return error_response(exc)


@app.get('/list/asn/{ip}/{mask}', response_model=ListAsnPrefixGetResponse)
@cache_result('prefix_asns')
async def get_list_asn_prefix(ip: str, mask: int) -> ListAsnPrefixGetResponse:
    """
    List all ASNs that announce a given prefix.

    Sourced from IRRExplorer.

    Path Arguments:

    - `ip` (str): The IP address to look up
    - `mask` (int): The prefix length
    """
    
    validated_prefix = validate_prefix(f"{ip}/{mask}")
    try:
        routing_data = await get_prefix_routing_data(validated_prefix)
        asns = []
        for prefix_info in routing_data.prefixes:
            asns.extend(prefix_info.bgpOrigins)
        asns = set(asns)
        return ListAsnPrefixGetResponse(asns=sorted(list(asns)))
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching data: {str(e)}")


@app.get('/list/prefix/{asn}', response_model=ListPrefixAsnGetResponse)
@cache_result('asn_prefixes')
async def get_list_prefix_asn(asn: int) -> ListPrefixAsnGetResponse:
    """
    List all prefixes announced by a given ASN.

    Sourced from IRRExplorer.

    Path Arguments:

    - `asn` (int): The ASN to look up
    """

    validated_asn = validate_asn(asn)
    now = datetime.datetime.now().replace(tzinfo=datetime.timezone.utc)
    try:
        routing_data = await get_asn_routing_data(validated_asn)
        prefixes = set()
        for prefix_info in routing_data.directOrigin + routing_data.overlaps:
            if validated_asn in prefix_info.bgpOrigins:
                prefixes.add(prefix_info.prefix)
        return ListPrefixAsnGetResponse(
            prefixes=sorted(list(prefixes)), 
            sources=[
                Source(
                    urls=[routing_data.source.url],
                    handle=f"AS{validated_asn}",
                    created=now,
                    updated=now
                )
            ]
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Error fetching data: {str(e)}")